## @file abttt.py
#  @title abttt
#  @author Jenny Feng Chen
#  @date 04/07/2016

def main():
    printIntro()
    mode,initial= getInputs()
    final = abttt(mode,initial)
    print(final)
    
#prints an introduction
def printIntro():
    return "This is a game of tic-tac-toe"

#get all the necessary inputs for the game 
def getInputs():
    #ask for how many players are playing 
    mode=int(input("Is it 1 player mode or 2 player mode?(0 for cp vs cp): "))
    #ask for the initial state
    initial=input("enter the initial state seperated by comma: ").split(',')
    return mode,initial

def TreeBuildAB(S,player):
#takes initial state and player initial
#returns a list of all game states generated by the game tree with root S
     return helper(S,player,True,-1,1)

def helper(S,player,isMax,alpha,beta):
    l=[]
    for n in range(len(S)):
        l.append(S[n])
    #change the oppo value when the turn changes
    if player=='X':
        oppo='O'
    else:
        oppo='X'
    #first checking the base case whether it is a winning state for X
    if checkWinState(S,player)==True:
        if isMax==True:
            l.append(1)
            l.append(player)
            l.append((-1,-1))
            #when go into this if statement, it means turn X and alpha would be 1
            l.append((1,beta))
            return l
        else:
             l.append(-1)
             l.append(player)
             l.append((-1,-1))
             l.append((alpha,-1))
             return l
    #checking the base case whether it is a winning state for O
    if checkWinState(S,oppo)==True:
        if isMax==True:
            l.append(-1)
            l.append(player)
            l.append((-1,-1))
            #when go into this if statement, it means turn O and alpha would be -1
            l.append((-1,beta))
            return l
        else:
            l.append(1)
            l.append(player)
            l.append((-1,-1))
            l.append((alpha,1))
            return l
    isFull=True
    #check whether there is space in the state
    for i in range(len(S)):
        if S[i]==' ':
            isFull=False
            break
    #if no space then return value 0 which means draw
    if isFull==True:
         l.append(0)
         l.append(player)
         l.append((-1,-1))
         #when state is full, the best result for turn X
         #would be getting a draw value 0 for alpha
         #and the best result for O would be also getting a draw value 0 for beta
         if isMax==True:
             l.append((0,beta))
         else:
             l.append((alpha,0))
         return l
    count=[]
    #find the space in the state and take the index of each of the space into a list
    for i in range(len(S)):
        if S[i]==' ':
            count.append(i)
    value=[]
    #put the player to the space and call the function to determine the value of state
    for i in range(len(count)):
        S[count[i]]=player
        L=helper(S,oppo,not isMax,alpha,beta)
        #taking alpha beta from the list
        a=L[len(L)-1][0]
        b=L[len(L)-1][1]
        #compare the current beta or alpha to the original alpha or beta respectively
        if isMax==True:
            if b>alpha:
                alpha=b
        else:
            if a<beta:
                beta=a
        value.append(L[9])
        S[count[i]]=' '
        #cut off when alpha is greater than beta
        if alpha>=beta:
            break
    #take the maximum value or minimum value for the current player and determine the position
    if isMax==True:
        val=max(value)
        pos=value.index(max(value))
    else:
        val=min(value)
        pos=value.index(min(value))
    #convert to the coordinate system
    move=(count[pos]//3,count[pos]%3)
    l.append(val)
    l.append(player)
    l.append(move)
    l.append((alpha,beta))
    return l
# check whether the state is a winning state 
def checkWinState(state, XorO):
    return ((state[6] == XorO and state[7] == XorO and state[8] == XorO) or # across the top
            (state[3] == XorO and state[4] == XorO and state[5] == XorO) or # across the middle
            (state[0] == XorO and state[1] == XorO and state[2] == XorO) or # across the bottom
            (state[6] == XorO and state[3] == XorO and state[0] == XorO) or # down the left side
            (state[7] == XorO and state[4] == XorO and state[1] == XorO) or # down the middle
            (state[8] == XorO and state[5] == XorO and state[2] == XorO) or # down the right side
            (state[6] == XorO and state[4] == XorO and state[2] == XorO) or # diagonal
            (state[8] == XorO and state[4] == XorO and state[0] == XorO)) # diagonal
        
def abttt(mode,init):
    printState(init)
    playerX,playerO='',''
    current=init
    while isBoardFull(current)==False:
        #game mode for 0 player
        if mode==0:
            #get the best next move for X
            compX=TreeBuildAB(current,'X')[-2]
            print('X-move: ',compX)
            #change the coordinate system into index
            compX=positionChange(compX)
            #print the current state after taking the move
            current=getCurrent(current,compX,'X')
            #check whether it is in a winning state for X
            if checkWinState(current,'X')==True :
                return "Computer X is the winner"
            #check whether the board is full
            if isBoardFull(current)==True: break
            #get the next best move for O
            compO=TreeBuildAB(current,'O')[-2]
            print('O-move: ',compO)
            #change the coordinate system into index
            compO=positionChange(compO)
            #print the current state after taking the move
            current=getCurrent(current,compO,'O')
            if checkWinState(current,'O')==True :
                return "Computer O is the winner"
        #game mode for 1 player and 1 computer
        if mode==1:
            space=0
            #while loop for overslapping position
            while space==0:
                playerX=eval(input("X-player's next move: "))
                #changing coordinate system
                playerX=positionChange(playerX)
                if current[playerX]=='X' or current[playerX]=='O':
                    print('Position is occupied. Please enter again.')
                    #print the current state
                    printState(current)
                else: break
            current=getCurrent(current,playerX,'X')
            #check whether it is in a winning state
            if checkWinState(current,'X')==True:
                return("Player X is the winner")
            if isBoardFull(current)==True: break
            #computer takes the best move by calling treebuild function
            computer=TreeBuildAB(current,'O')[-2]
            #changing coordinate system
            computer=positionChange(computer)
            #print the current state after moving
            current=getCurrent(current,computer,'O')
            #check whether it is in a winning state
            if(checkWinState(current,'O')==True):
                return "Computer O is the winner"
        #game mode for 2 players
        if mode==2:
            space=0
            #while loop for overslapping position
            while space==0:
                playerX=eval(input("X-player's next move: "))
                playerX=positionChange(playerX)
                if current[playerX]=='X' or current[playerX]=='O':
                    print('Position is occupied. Please enter again.')
                    printState(current)
                else: break
            current=getCurrent(current,playerX,'X')
            if(checkWinState(current,'X')==True):
                return "Player X is the winner"
            if isBoardFull(current)==True: break
            #while loop for overslapping position
            while space==0:
                playerO=eval(input("O-player's next move: "))
                playerO=positionChange(playerO)
                if current[playerO]=='X' or current[playerO]=='O':
                    print('Position is occupied. Please enter again.')
                    printState(current)
                else: break
            current=getCurrent(current,playerO,'O')
            if(checkWinState(current,'O')==True):
                return "Player O is the winner"
    return "The match is draw"

#print the table of tictactoe
def printState(initial):
    print("Current State: ")
    n=0
    print("-------")
    for x in range(3):
        print('|',end='')
        for y in range(3):
            print(initial[n],end='|')
            n=n+1
        print()
        print("-------")

# takes the current state,player and XorO and updates initial state       
def getCurrent(current,player,XorO):
    current[player]=XorO
    printState(current)
    return current

#given the coordinates by the user change them into index number
def positionChange(player):
    a=player[0]
    b=player[1]
    n=0
    for i in range(3):
        for j in range(3):
            if i==int(a) and j==int(b):
                return n
            else:
                n=n+1
# Return True if every space on the board has been taken. Otherwise return False.
def isBoardFull(state):
    for i in range(9):
        if isBoardHasSpace(state, i):
            return False
    return True

# Return true if the passed move is free on the passed board.
def isBoardHasSpace(state, move):
    return state[move] == ' '                
