## @file minimaxttt.py
#  @title minmaxttt
#  @author Jenny Feng Chen
#  @date 04/07/2016

def main():
    printIntro()
    mode,initial= getInputs()
    final = minimaxttt(mode,initial)
    print(final)
    
#prints an introduction
def printIntro():
    #print an introduction 
    return "This is a game of tic-tac-toe"

#get all the necessary inputs for the game 
def getInputs():
    #ask for how many players are playing 
    mode=int(input("Is it 1 player mode or 2 player mode?(0 for cp vs cp): "))
    #ask for the initial state
    print("Example of input state: ' , ,X, , ,O, , , '")
    initial=input("Enter the initial state and seperated by comma: ").split(',')
    return mode,initial

def TreeBuild(S,player):
#takes initial S and player initial
#returns a list of all game states generated by the game tree with root S
     return helper(S,player,True)

def helper(S,player,isMax):
    l=[]
    for i in range(len(S)):
        l.append(S[i])
    #change the opponent value when the turn changes
    if player=='X':
        oppo='O'
    else:
        oppo='X'
    #first checking the base case whether it is a winning state for X
    if checkWinState(S,player)==True:
        if isMax==True:
            l.append(1)
            l.append(player)
            l.append((-1,-1))
            return l
        else:
             l.append(-1)
             l.append(player)
             l.append((-1,-1))
             return l
    #checking the base case whether it is a winning state for O
    if checkWinState(S,oppo)==True:
        if isMax==True:
            l.append(-1)
            l.append(player)
            l.append((-1,-1))
            return l
        else:
            l.append(1)
            l.append(player)
            l.append((-1,-1))
            return l
    isFull=True
    #check whether there is space in the state
    for i in range(len(S)):
        if S[i]==' ':
            isFull=False
            break
    #if no space then return value 0 which means draw
    if isFull==True:
         l.append(0)
         l.append(player)
         l.append((-1,-1))
         return l
    count=[]
    #find the space in the state and take the index of each of the space into a list
    for i in range(len(S)):
        if S[i]==' ':
            count.append(i)
    value=[]
    #put the player to the space and call the function to determine the value of state
    for i in range(len(count)):
        S[count[i]]=player
        L=helper(S,oppo,not isMax)
        value.append(L[9])
        S[count[i]]=' '
    #take the maximum value or minimum value for the current player and determine the position
    if isMax==True:
        val=max(value)
        pos=value.index(max(value))
    else:
        val=min(value)
        pos=value.index(min(value))
    #convert to the coordinate system
    move=(count[pos]//3,count[pos]%3)
    l.append(val)
    l.append(player)
    l.append(move)
    return l

#function for checking the winning state
def checkWinState(S, player):
    return ((S[6] == player and S[7] == player and S[8] == player) or # across the top
            (S[3] == player and S[4] == player and S[5] == player) or # across the middle
            (S[0] == player and S[1] == player and S[2] == player) or # across the bottom
            (S[6] == player and S[3] == player and S[0] == player) or # down the left side
            (S[7] == player and S[4] == player and S[1] == player) or # down the middle
            (S[8] == player and S[5] == player and S[2] == player) or # down the right side
            (S[6] == player and S[4] == player and S[2] == player) or # diagonal
            (S[8] == player and S[4] == player and S[0] == player)) # diagonal
        
def minimaxttt(mode,init):
    printState(init)
    playerX,playerO='',''
    current=init
    while isBoardFull(current)==False:
        #game mode for 0 player
        if mode==0:
            #get the best next move for X
            compX=TreeBuild(current,'X')[-1]
            print('X-move: ',compX)
            #change the coordinate system into index
            compX=positionChange(compX)
            #print the current state after taking the move
            current=getCurrent(current,compX,'X')
            #check whether it is in a winning state for X
            if checkWinState(current,'X')==True :
                return "Computer X is the winner" 
            #check whether the board is full
            if isBoardFull(current)==True: break
            #get the next best move for O
            compO=TreeBuild(current,'O')[-1]
            print('O-move: ',compO)
            #change the coordinate system into index
            compO=positionChange(compO)
            #print the current state after taking the move
            current=getCurrent(current,compO,'O')
            if checkWinState(current,'O')==True :
                return "Computer O is the winner" 
        #game mode for 1 player and 1 computer
        if mode==1:
            space=0
            #while loop for overslapping position
            while space==0:
                playerX=eval(input("X-player's next move: "))
                #changing coordinate system
                playerX=positionChange(playerX)
                if current[playerX]=='X' or current[playerX]=='O':
                    print('Position is occupied. Please enter again.')
                    #print the current state
                    printState(current)
                else: break
            current=getCurrent(current,playerX,'X')
            #check whether it is in a winning state
            if checkWinState(current,'X')==True :
                return "Player X is the winner" 
            if isBoardFull(current)==True: break
            #computer takes the best move by calling treebuild function
            computer=TreeBuild(current,'O')[-1]
            #changing coordinate system
            computer=positionChange(computer)
            #print the current state after moving
            current=getCurrent(current,computer,'O')
            #check whether it is in a winning state
            if checkWinState(current,'O')==True :
                return "Computer O is the winner"
        #game mode for 2 players
        if mode==2:
            space=0
            #while loop for overslapping position
            while space==0:
                playerX=eval(input("X-player's next move: "))
                playerX=positionChange(playerX)
                if current[playerX]=='X' or current[playerX]=='O':
                    print('Position is occupied. Please enter again.')
                    printState(current)
                else: break
            current=getCurrent(current,playerX,'X')
            if checkWinState(current,'X')==True :
                return "Player X is the winner"
            if isBoardFull(current)==True: break
            #while loop for overslapping position
            while space==0:
                playerO=eval(input("O-player's next move: "))
                playerO=positionChange(playerO)
                if current[playerO]=='X' or current[playerO]=='O':
                    print('Position is occupied. Please enter again.')
                    printState(current)
                else: break
            current=getCurrent(current,playerO,'O')
            if checkWinState(current,'O')==True :
                return "Player O is the winner"
    return "The match is draw"

#print the table of tictactoe
def printState(S):
    print("Current State: ")
    n=0
    print("-------")
    for x in range(3):
        print('|',end='')
        for y in range(3):
            print(S[n],end='|')
            n=n+1
        print()
        print("-------")

# takes the current state,player and their letter and updates initial state       
def getCurrent(current,player,letter):
    current[player]=letter
    printState(current)
    return current

#given the coordinates by the user change them into index number
def positionChange(player):
    a=player[0]
    b=player[1]
    n=0
    for i in range(3):
        for j in range(3):
            if i==int(a) and j==int(b):
                return n
            else:
                n=n+1
# Return True if every space on the board has been taken. Otherwise return False.
def isBoardFull(state):
    for i in range(9):
        if isBoardHasSpace(state, i):
            return False
    return True

# Return true if the passed move is free on the passed board.
def isBoardHasSpace(state, move):
    return state[move] == ' '                

